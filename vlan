#!/usr/bin/env python
import re
import subprocess
import argparse
import os.path


filename="/etc/vlanconfig"
back_config={}

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("action", default="restart", choices=["stop", "start", "restart"],
                                help="Perform action {stop|start|restart}")
    parser.add_argument('vlans', nargs='*',
                                help='vlans to execute on (e.g. vlan2500 vlan100)')
    parser.add_argument("-v", "--verbose", action="count", default=0,
                                help="increase output verbosity")
    parser.add_argument("--dry-run", action="store_true",
                                help='run without actualy performing the commands')

    args = parser.parse_args()
    #print args
    globals().update(vars(args))

def parse_line(line):
    cleanup=re.compile("#.*")
    parse=re.compile("^([^\s]*)\s*([^\s]*)\s*([^\s]*)\s*([^\s]*)\s*([^\s]*)\s*([^\s]*)\s*([^\s]*)\s*([^\s]*)\s*([^\s]*)")
    vlan_config=re.findall(parse,re.sub(cleanup,"",line))[0]
    # parse known variables
    eth,vlanid,ip,mask,rate=vlan_config[:5]
    
    return eth,vlanid,ip,mask,rate
    
def parse_back(line):
    eth,vlanid,ip,mask,rate=parse_line(line)
    if eth:
        back_config[eth+vlanid]=eth,vlanid,ip,mask,rate
        
def hash_back_file(filename):
    backfile=filename+".back"
    if not os.path.isfile(backfile): return None
    with open(backfile) as f:
        for line in f:
            parse_back(line)
    
def run_cmd(cmd):
    stdout=":"
    if verbose:
        print cmd
        
    if not dry_run:
        cmd_subprocess=subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        stdout=cmd_subprocess.stdout.read()
        if (stdout != "") and (stdout != ":"):
            print stdout.rstrip()
        if cmd_subprocess.wait()==0:
            return True
        else:
            return False
    else:
        return True

def vlan_add(eth, vlanid):
    cmd="vconfig add %s %s" % (eth, vlanid)
    run_cmd(cmd)
    pass

def vlan_ip_add(vlan, ip, mask):
    cmd="ip address add dev %s %s%s" %(vlan, ip, mask)
    run_cmd(cmd)
    cmd="ip link set %s up" % vlan
    run_cmd(cmd)
    pass

def vlan_rate(eth, vlanid, rate):
    vlan="vlan"+vlanid
    cmd="tc qdisc del dev %s root" % vlan
    run_cmd(cmd)
    cmd="tc qdisc add dev %s root handle 1: htb r2q 1 default 1" % vlan
    run_cmd(cmd)
    cmd="tc class add dev %s parent 1:1 classid 1:1 htb quantum 1000000 rate %smbit ceil %smbit burst 6k" % (vlan,rate,rate)
    run_cmd(cmd)
    cmd="tc qdisc add dev %s parent 1:1 handle 10 sfq perturb 10" % vlan
    run_cmd(cmd)

def vlan_stop(vlanname):
    #cmd="ip link set %s down" % vlanname
    #run_cmd(cmd)
    cmd="vconfig rem "+vlanname
    run_cmd(cmd)
    
    
def vlan_start(eth,vlanid,ip,mask,rate):
    # configure interfaces
    if vlan_add(eth,vlanid):
        vlan_ip_add("vlan"+vlanid,ip,mask)

        if rate:
            vlan_rate(eth, vlanid, rate)

            
def process_start(line):
    eth,vlanid,ip,mask,rate=parse_line(line)
    if not eth: return

    if ('vlan'+vlanid in vlans) or not vlans:
        vlan_start(eth,vlanid,ip,mask,rate)

        
#    if tuple([eth,vlanid,ip,mask,rate])!=back_config.get(eth+vlanid):
#        print [eth,vlanid,ip,mask,rate]
#        print back_config.get(eth+vlanid)
#        if action=="start" or action=="restart":
#            vlan_start(eth,vlanid,ip,mask,rate)



# MAIN
parse_args()


if action=="stop" or action=="restart":
    hash_back_file(filename)

if action=="stop":
    if vlans:
        for vlanname in vlans:
            vlan_stop(vlanname)
    else:
        for line in back_config:
            [eth,vlanid,ip,mask,rate]=back_config.get(line)
            vlan_stop('vlan'+vlanid)
    
if action=="start" or action=="restart":
    with open(filename) as f:
        for line in f:
            if action=="start":
                process_start(line)
            if action=="restart":
                process_start(line)
            
